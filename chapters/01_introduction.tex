\chapter{Introduction}\label{chapter:introduction}

% Citation test~\parencite{latex}.

Functional lists (\autoref{fig:example-list}) are a handy and easy-to-use data structure in functional programming. However, compared to imperative arrays, |lookup| and |update| operations on lists have a significantly worse runtime of $\mathcal{O}(n)$ instead of $\mathcal{O}(1)$. 

\begin{figure}[htpb]
\includegraphics[trim={0 22,2cm 0 2,3cm},clip, width=1.00\textwidth]{figures/Theory_Intro.pdf}
\caption[Example functional list implementation]{An example implementation of a functional list.}\label{fig:example-list}
\end{figure}

\noindent Then why not replace lists with arrays at compile time? Like that, the functional language's methodological benefits could be preserved, and also the runtime of imperative arrays. In section X, we will apply this simple method. The problem with the method is that arrays are ephemeral, meaning that updates are destructive, like for most imperative data structures (Okasaki, 2). Contrary to imperative languages, all data structures are automatically persistent in functional languages (Okasaki, 2).
If we use a list in a non-linear way, we would need to copy the corresponding array, which is costly in terms of runtime and memory. \\
To cope with that, we use diff arrays or trailer arrays (Bloss 1989 + link section X), which store their updates in a tree-like structure next to the array (Kumar 2017 706). 
With them, we can have lookup and update operations in $\mathcal{O}(1)$ for the most recent version of the data structure. \\
This thesis aims to automatically convert functional programs using lists to imperative ones using (diff) arrays. Additionally, we will automatically create equivalence proofs to ensure that the two versions of the program are doing the same. We use the Isabelle/HOL theorem prover (link section) for this purpose. We can reason about imperative programs using the Imperative/HOL framework (link section) in Isabelle and a separation logic (link section) built on top of it. Using this setup, we implemented an infrastructure to parallelly translate the functional programs to imperative ones and create equivalence proofs (link section).
